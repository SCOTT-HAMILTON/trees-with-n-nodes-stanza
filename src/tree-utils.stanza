defpackage tree/utils :
   import core
   import collections
   import tree
   import utils

public defn make-tree (N: Int) -> Tree<String> :
    var tree = Tree("R", false, N)
    for i in 0 to N do :
        add-child(tree, to-string(i + 1))
    tree

public defn tr (value: String) -> Tree<String> :
    Tree(value)

public defn minus (t1: Tree<String>, t2: Tree<String>) -> Tree<String>:
    var tree = DeepCopy(t1)
    add-child(tree, t2)
    tree

public defn apply-child-possibility (
        order: Seqable<Tree<String>> & Lengthable) ->  Tree<String>:
    val tree = Tree("R", false, length(order))
    for c in order do :
        add-child(tree, DeepCopy(c))
    tree

public defn apply-repartition (repartitions: List<Int>) :
    val groups-ps = Vector<List<List<Tree<String>>>>()
    val indexed-reparts = zip(0 to length(repartitions), repartitions)
    val g-reparts-table = group-by({_[1]}, indexed-reparts)
    defn group-compare-min-index (g1: List<[Int, Int]>, g2: List<[Int, Int]>) : 
        defn g-min-index (g: List<[Int, Int]>) :
            minimum({_[0]}, g)
        g-min-index(g1) < g-min-index(g2)
    val tmp-groups: Array<List<[Int, Int]>> = to-array<List<[Int, Int]>>(values(g-reparts-table))
    qsort!(tmp-groups, group-compare-min-index)
    val groups: List<List<Int>> = map(fn (g) : map({_[1]}, g), to-list(tmp-groups))
    for g in groups do :
        val r = g[0]
        val group-c-ps = if r == 0 :
            to-array<Tree<String>>([ make-tree(0) ])
        else :
            to-array<Tree<String>>(trees-with-n-nodes(r + 1))
        val ps: List<List<Tree<String>>> = to-list(combinations-with-replacement(group-c-ps, length(g)))
        add(groups-ps, ps)

    generate<Tree<String>> :
        defn lazy-flatten (x) :
           generate :
              defn loop (x) :
                 match(x) :
                    (x:List) : do(loop, x)
                    (x) : yield(x)
              loop(x)
        for combination in to-list(groups-ps) all-combinations :
            val childs = to-list(lazy-flatten(combination))
            yield(apply-child-possibility(childs))

public defn apply-repartition (f: Tree<String> -> False, repartitions: List<Int>) :
    val seq = apply-repartition(repartitions)
    while not empty?(seq) :
          f(next(seq))

public defn trees-with-n-nodes (N: Int) :
    generate<Tree<String>> :
        for root-childs in in-reverse(1 to N) do :
            val tree = make-tree(root-childs)
            val left = N - root-childs - 1
            if left == 0 :
                yield(tree)
            else if left == 1 :
                set-child(tree, root-childs - 1, make-tree(1))
                yield(tree)
            else if left > 1 :
                val repartitions = repart(left, root-childs)
                for repartition in repartitions do :
                    for t in repartition apply-repartition:
                        yield(t)
    
public defn trees-with-n-nodes (f: Tree<String> -> False, N: Int) :
    val seq = trees-with-n-nodes(N)
    while not empty?(seq) :
          f(next(seq))
